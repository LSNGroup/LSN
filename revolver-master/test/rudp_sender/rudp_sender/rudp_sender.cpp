#include "core/core_packet.h"
#include "base_reactor_instance.h"
#include "base_bin_stream.h"
#include "base_packet.h"
#include "rudp_interface.h"
#include "udt/udt.h"

#include <iostream>


using namespace BASE;

class RUDPTestPacket : public CBasePacket
{
public:
	RUDPTestPacket()
	{
		user_id		= 1000;
		ts			= 0;
		nick		= "zerok775";
		ctx			= "1234567890987654321";
	};

	~RUDPTestPacket()
	{

	}

	virtual void release_self()
	{
		delete this;
	}

protected:
	//编码解码函数
	virtual void	Pack(BinStream& strm) const
	{
		strm << user_id << ts << nick << ctx;
	};

	//解码函数
	virtual void	UnPack(BinStream& strm)
	{
		strm >> user_id >> ts >> nick >> ctx;
	};

	virtual void	Print(std::ostream& os) const
	{
	};

public:
	uint32_t	user_id;
	uint64_t	ts;
	string		nick;
	string		ctx;
};



int32_t send_pack(UDTSOCKET u, RUDPTestPacket& packet)
{
	int32_t ret = -1;
	char buf[16*1024];

	*(uint32_t *)(buf+0) = htonl(4+8+4+packet.nick.length()+4+packet.ctx.length());
	*(uint32_t *)(buf+4) = htonl(packet.user_id);
	*(uint64_t *)(buf+8) = packet.ts;
	*(uint32_t *)(buf+16) = htonl(packet.nick.length());
	memcpy(buf+20,                      packet.nick.c_str(), packet.nick.length());
	*(uint32_t *)(buf+20+packet.nick.length()) = htonl(packet.ctx.length());
	memcpy(buf+20+packet.nick.length()+4, packet.ctx.c_str(),  packet.ctx.length());

	ret = UDT::send(u, buf, 4+4+8+4+packet.nick.length()+4+packet.ctx.length(), 0);
	if (ret < 0) {
		cout << "UDT::send() failed!" << endl;
	}

	return ret;
}


DWORD WINAPI SendThreadFn(LPVOID pvThreadParam)
{
	UDTSOCKET u = *(UDTSOCKET *)pvThreadParam;
	int ret;
	int count_ = 0;
	while (true)
	{
		RUDPTestPacket packet;
		packet.user_id = count_;
		packet.ts = CBaseTimeValue::get_time_value().msec();
		packet.nick = "zerok775";
		packet.ctx = "test01234567678901234567890Ok123456745678901234567890012347678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok1234567456789012345678900127678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok1234567456789012345678900127678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok1234567456789012345678900127678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok1234567456789012345678900127678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok1234567456789012345678900127678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok1234567456789012345678900127678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok1234567456789012345678900125678901234567890Ok123456745678907678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok1234567456789012345678900127678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok1234567456789012345678900127678901234567890Ok1234567457678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok1234567456789012345678900127678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok1234567456789012345678900127678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok1234567456789012345678900127678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok1234567456789012345678900127678901234567890Ok1234567457678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok123456745678901234567890012678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok123456745678901234567890012678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok1234567456789012345678900121234567890testO567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testOk12345678901234567890123450123456789k123456567890123456789012345678901234567890Ok12345k12345678901234567890123450123456789k123456567890123456789012345678901234567890Ok123456745678901234567890testOk12345678901234567890123450123456789k12345656789012345678901234567890Ok1234567890123458901234567890Ok12345678901234567890123456789012345678901234567890123456789012345678901234567678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testOk12345678901234567890123450123456789k123456567890123456789012345678901234567890Ok12345k12345678901234567890123450123456789k123456567890123456789012345678901234567890Ok123456745678901234567890testOk12345678901234567890123450123456789k12345656789012345678901234567890Ok1234567890123458901234567890Ok1234567890123456789012345678901234567890123456789012345678901234567890123456789067678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testOk12345678901234567890123450123456789k123456567890123456789012345678901234567890Ok12345k12345678901234567890123450123456789k123456567890123456789012345678901234567890Ok123456745678901234567890testOk12345678901234567890123450123456789k12345656789012345678901234567890Ok1234567890123458901234567890Ok1234567890123456789012345678901234567890123456789012345678901234567890123456789067678901234567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testO567890Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testOk12345678901234567890123450123456789k123456567890123456789012345678901234567890Ok12345k12345678901234567890123450123456789k123456567890123456789012345678901234567890Ok123456745678901234567890testOk12345678901234567890123450123456789k12345656789012345678901234567890Ok1234567890123458901234567890Ok1234567890123456789012345678901234567890123456789012345678901234567890123456789067890Ok123456745678901234567890testOk1234567890123456701234567890Ok123456789345678901234567890Ok123456789012345678901234567890Ok1234567890123456789012345678901234567890Ok1234567890123456789012345678901234567890Ok123456790Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testOk12345678901234567890123450123456789k123456567890123456789012345678901234567890Ok123456745678901234567890testOk12345678901234567890123450123456789k12345656789012345678901234567890Ok1234567890123458901234567890Ok12345678901234567890123456789012345678901234567890123456789012345678901234567890Ok123456745678901234567890testOk1234567890123456701234567890Ok123456789345678901234567890Ok123456789012345678901234567890Ok1234567890123456789012345678901234567890Ok12345678901234567890123456789012345689012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789Ok123456745678901234567890012345678901234567890Ok123456745678901234567890testOk12345678901234567890123450123456789k123456567890123456789012345678901234567890Ok123456745678901234567890testOk12345678901234567890123450123456789k12345656789012345678901234567890Ok1234567890123458901234567890Ok12345678901234567890123456789012345678901234567890123456789012345678901234567890Ok123456745678901234567890testOk1234567890123456701234567890Ok123456789345678901234567890Ok123456789012345678901234567890Ok1234567890123456789012345678901234567890Ok1234567890123456789012345678901234567890Ok12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890testOk12345678901234567890123450123456789k12345656789012345678901234567890Ok12345678901234567890123456789012345678901234567890123456789012345678901234567890Ok123456745678901234567890testOk12345678901234567890123450123456789k12345656789012345678901234567890Ok12345678901234567890123450123456789k12345656789012345678901234567890Ok12345678901234567567890123450123456789k12345656789012345678901234567890Ok12345678901234567234567890123450123456789k12345656789012345678901234567890Ok12345678901234567678901234567890123456789012345678901234567890123456789012345678901234567890OOk12345677890Ok12345678901234567678901234567890123456789012345678901234567890123456789012345678901234567890OOk1234567";

		ret = send_pack(u, packet);
		if (ret < 0) {
			break;
		}
		if (count_ % 500 == 0) {//cout是导致传输速率上不来的罪魁祸首！！！
			cout << "UDTSocket[" << u << "]: Send " << ret << " bytes..." << endl;
		}
		count_ += 1;
	}
	cout << "UDTSocket[" << u << "]: Sending thread exit..." << endl;
	return 0;
}

void MyDirectUdpFunc(UDPSOCKET sock, char *data, int len, sockaddr* his_addr, int addr_len)
{
	Inet_Addr addr(*(sockaddr_in *)his_addr);
	cout << "Direct udp recv:" << data << ", len=" << len << ", his_addr=" << addr << endl;
}

int main(int agc, char* argv[])
{
	cout << "start rudp sender... " << endl;

	UDT::startup();


	int ret;
	bool connected = false;
	sockaddr_in my_addr;
	sockaddr_in their_addr;
	UDPSOCKET udp_sock = INVALID_SOCKET;
	UDTSOCKET usock = UDT::INVALID_SOCK;
	UDTSOCKET usock_slave = UDT::INVALID_SOCK;
	DWORD dwThreadID;
	HANDLE hThread;
	DWORD dwThreadID2;
	HANDLE hThread2;

	while(true)
	{
		char c = getchar();

		if(c == 'e')
		{
			break;
		}
		else if(c == 'C')
		{
			udp_sock = socket(AF_INET, SOCK_DGRAM, 0);
			if (INVALID_SOCKET == udp_sock) {
				cout << "udp socket() failed!" << endl;
				break;
			}

			my_addr.sin_family = AF_INET;
			my_addr.sin_port = htons(2030);
			my_addr.sin_addr.s_addr = INADDR_ANY;
			memset(&(my_addr.sin_zero), '\0', 8);
			ret = bind(udp_sock, (sockaddr *)&my_addr, sizeof(my_addr));
			if (ret != 0) {
				cout << "udp bind() failed!" << endl;
				break;
			}

			usock = UDT::socket(AF_INET, SOCK_STREAM, 0);
			if (UDT::INVALID_SOCK == usock) {
				cout << "UDT::socket() failed!" << endl;
				break;
			}

			ret = UDT::bind(usock, udp_sock);
			if (ret != 0) {
				cout << "UDT::bind() failed!" << endl;
				break;
			}

			their_addr.sin_family = AF_INET;
			their_addr.sin_port = htons(20200);
			their_addr.sin_addr.s_addr = inet_addr("192.168.0.100");
			//their_addr.sin_addr.s_addr = inet_addr("42.96.153.190");
			//their_addr.sin_addr.s_addr = inet_addr("116.255.159.32");
			memset(&(their_addr.sin_zero), '\0', 8);
			ret = UDT::connect(usock, (sockaddr *)&their_addr, sizeof(their_addr));
			if (ret != 0) {
				cout << "UDT::connect() failed!" << endl;
				break;
			}
			connected = true;
			cout << "UDT connected to the server!!! rudp_id = " << usock << endl;

			UDT::register_direct_udp_recv(usock, MyDirectUdpFunc);

			hThread = ::CreateThread(NULL,0,SendThreadFn,&usock,0,&dwThreadID);
		}
		else if(c == 'c')
		{
			if (connected)
			{
				usock_slave = UDT::socket(AF_INET, SOCK_STREAM, 0);
				if (UDT::INVALID_SOCK == usock_slave) {
					cout << "UDT::socket() failed!" << endl;
					break;
				}

				ret = UDT::bind2(usock_slave, udp_sock);
				if (ret != 0) {
					cout << "UDT::bind2() failed!" << endl;
					break;
				}

				their_addr.sin_family = AF_INET;
				their_addr.sin_port = htons(20200);
				their_addr.sin_addr.s_addr = inet_addr("192.168.0.100");
				//their_addr.sin_addr.s_addr = inet_addr("42.96.153.190");
				//their_addr.sin_addr.s_addr = inet_addr("116.255.159.32");
				memset(&(their_addr.sin_zero), '\0', 8);
				ret = UDT::connect(usock_slave, (sockaddr *)&their_addr, sizeof(their_addr));
				if (ret != 0) {
					cout << "UDT::connect() failed!" << endl;
					break;
				}
				cout << "UDT connected to the server!!! rudp_id = " << usock_slave << endl;

				hThread2 = ::CreateThread(NULL,0,SendThreadFn,&usock_slave,0,&dwThreadID2);
			}
			else {
				cout << "Please connect usock first!" << endl;
			}
		}
		else if(c == 'd')
		{
			if (UDT::INVALID_SOCK != usock_slave) {
				cout << "UDT::close(" << usock_slave << ")..." << endl;
				UDT::close(usock_slave);
				usock_slave = UDT::INVALID_SOCK;
				::WaitForSingleObject(hThread2,  INFINITE);
				::CloseHandle(hThread2);
			}
		}
		else if(c == 'D')
		{
			if (connected && UDT::INVALID_SOCK == usock_slave) {
				cout << "UDT::close(" << usock << ")..." << endl;
				UDT::close(usock);
				usock = UDT::INVALID_SOCK;
				::WaitForSingleObject(hThread,  INFINITE);
				::CloseHandle(hThread);
				connected = false;
			}
			else {
				cout << "Please close usock_slave first!" << endl;
			}
		}
	}

	UDT::unregister_direct_udp_recv(usock);


	if (UDT::INVALID_SOCK != usock_slave) {
		UDT::close(usock_slave);
	}
	if (UDT::INVALID_SOCK != usock) {
		UDT::close(usock);
	}
	if (INVALID_SOCKET != udp_sock) {
		closesocket(udp_sock);
	}
	UDT::cleanup();

	return 0;
}
